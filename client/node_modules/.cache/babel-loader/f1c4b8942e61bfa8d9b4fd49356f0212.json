{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar NestedField_1 = require(\"./NestedField\");\n\nvar Utils =\n/** @class */\nfunction () {\n  function Utils() {}\n\n  Utils.resolveVariables = function (operations) {\n    var ret = {};\n\n    for (var _i = 0, operations_1 = operations; _i < operations_1.length; _i++) {\n      var _a = operations_1[_i],\n          variables = _a.variables,\n          fields = _a.fields;\n      ret = __assign(__assign(__assign({}, ret), variables), fields && Utils.getNestedVariables(fields) || {});\n    }\n\n    return ret;\n  }; // Convert object to name and argument map. eg: (id: $id)\n\n\n  Utils.queryDataNameAndArgumentMap = function (variables) {\n    return variables && Object.keys(variables).length ? \"(\" + Object.entries(variables).reduce(function (dataString, _a, i) {\n      var key = _a[0],\n          value = _a[1];\n      return \"\" + dataString + (i !== 0 ? \", \" : \"\") + (value && value.name ? value.name : key) + \": $\" + key;\n    }, \"\") + \")\" : \"\";\n  };\n\n  Utils.queryFieldsMap = function (fields) {\n    var _this = this;\n\n    return fields ? fields.map(function (field) {\n      if (NestedField_1.isNestedField(field)) {\n        return Utils.queryNestedFieldMap(field);\n      } else if (typeof field === \"object\") {\n        var values = Object.values(field)[0];\n        return Object.keys(field)[0] + \" \" + (values.length > 0 ? \"{ \" + _this.queryFieldsMap(values) + \" }\" : \"\");\n      } else {\n        return \"\" + field;\n      }\n    }).join(\", \") : \"\";\n  };\n\n  Utils.queryNestedFieldMap = function (field) {\n    return field.operation + \" \" + this.queryDataNameAndArgumentMap(field.variables) + \" \" + (field.fields.length > 0 ? \"{ \" + this.queryFieldsMap(field.fields) + \" }\" : \"\");\n  }; // Variables map. eg: { \"id\": 1, \"name\": \"Jon Doe\" }\n\n\n  Utils.queryVariablesMap = function (variables, fields) {\n    var variablesMapped = {};\n\n    var update = function (vars) {\n      if (vars) {\n        Object.keys(vars).map(function (key) {\n          variablesMapped[key] = typeof vars[key] === \"object\" ? vars[key].value : vars[key];\n        });\n      }\n    };\n\n    update(variables);\n\n    if (fields && typeof fields === \"object\") {\n      update(Utils.getNestedVariables(fields));\n    }\n\n    return variablesMapped;\n  };\n\n  Utils.getNestedVariables = function (fields) {\n    var variables = {};\n    fields === null || fields === void 0 ? void 0 : fields.forEach(function (field) {\n      if (NestedField_1.isNestedField(field)) {\n        variables = __assign(__assign(__assign({}, field.variables), variables), field.fields && Utils.getNestedVariables(field.fields));\n      }\n    });\n    return variables;\n  };\n\n  Utils.queryDataType = function (variable) {\n    var type = \"String\";\n    var value = typeof variable === \"object\" ? variable.value : variable;\n\n    if ((variable === null || variable === void 0 ? void 0 : variable.type) != null) {\n      type = variable.type;\n    } else {\n      // TODO: Should handle the undefined value (either in array value or single value)\n      var candidateValue = Array.isArray(value) ? value[0] : value;\n\n      switch (typeof candidateValue) {\n        case \"object\":\n          type = \"Object\";\n          break;\n\n        case \"boolean\":\n          type = \"Boolean\";\n          break;\n\n        case \"number\":\n          type = candidateValue % 1 === 0 ? \"Int\" : \"Float\";\n          break;\n      }\n    } // set object based variable properties\n\n\n    if (typeof variable === \"object\") {\n      if (variable.list === true) {\n        type = \"[\" + type + \"]\";\n      } else if (Array.isArray(variable.list)) {\n        type = \"[\" + type + (variable.list[0] ? \"!\" : \"\") + \"]\";\n      }\n\n      if (variable.required) {\n        type += \"!\";\n      }\n    }\n\n    return type;\n  };\n\n  return Utils;\n}();\n\nexports.default = Utils;","map":{"version":3,"sources":["../src/Utils.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;AAEA,IAAA,aAAA,GAAA,OAAA,CAAA,eAAA,CAAA;;AAGA,IAAA,KAAA;AAAA;AAAA,YAAA;AAAA,WAAA,KAAA,GAAA,CAiIC;;AAhIe,EAAA,KAAA,CAAA,gBAAA,GAAd,UAA+B,UAA/B,EAAiE;AAC/D,QAAI,GAAG,GAAQ,EAAf;;AAEA,SAAoC,IAAA,EAAA,GAAA,CAAA,EAAA,YAAA,GAAA,UAApC,EAAoC,EAAA,GAAA,YAAA,CAAA,MAApC,EAAoC,EAAA,EAApC,EAAgD;AAArC,UAAA,EAAA,GAAA,YAAA,CAAA,EAAA,CAAA;AAAA,UAAE,SAAA,GAAA,EAAA,CAAA,SAAF;AAAA,UAAa,MAAA,GAAA,EAAA,CAAA,MAAb;AACT,MAAA,GAAG,GAAA,QAAA,CAAA,QAAA,CAAA,QAAA,CAAA,EAAA,EACE,GADF,CAAA,EAEE,SAFF,CAAA,EAGI,MAAM,IAAI,KAAK,CAAC,kBAAN,CAAyB,MAAzB,CAAX,IAAgD,EAHnD,CAAH;AAKD;;AACD,WAAO,GAAP;AACD,GAXa,CADhB,CAcE;;;AACc,EAAA,KAAA,CAAA,2BAAA,GAAd,UAA0C,SAA1C,EAAoE;AAClE,WAAO,SAAS,IAAI,MAAM,CAAC,IAAP,CAAY,SAAZ,EAAuB,MAApC,GACH,MAAI,MAAM,CAAC,OAAP,CAAe,SAAf,EAA0B,MAA1B,CAAiC,UAAC,UAAD,EAAa,EAAb,EAA2B,CAA3B,EAA4B;UAAd,GAAA,GAAA,EAAA,CAAA,CAAA,C;UAAK,KAAA,GAAA,EAAA,CAAA,CAAA,C;AACtD,aAAO,KAAG,UAAH,IAAgB,CAAC,KAAK,CAAN,GAAU,IAAV,GAAiB,EAAjC,KACL,KAAK,IAAI,KAAK,CAAC,IAAf,GAAsB,KAAK,CAAC,IAA5B,GAAmC,GAD9B,IACiC,KADjC,GAED,GAFN;AAGD,KAJG,EAID,EAJC,CAAJ,GAIM,GALH,GAMH,EANJ;AAOD,GARa;;AAUA,EAAA,KAAA,CAAA,cAAA,GAAd,UAA6B,MAA7B,EAA4C;AAA5C,QAAA,KAAA,GAAA,IAAA;;AACE,WAAO,MAAM,GACT,MAAM,CACH,GADH,CACO,UAAC,KAAD,EAAM;AACT,UAAI,aAAA,CAAA,aAAA,CAAc,KAAd,CAAJ,EAA0B;AACxB,eAAO,KAAK,CAAC,mBAAN,CAA0B,KAA1B,CAAP;AACD,OAFD,MAEO,IAAI,OAAO,KAAP,KAAiB,QAArB,EAA+B;AACpC,YAAM,MAAM,GAAG,MAAM,CAAC,MAAP,CAAc,KAAd,EAAqB,CAArB,CAAf;AACA,eAAU,MAAM,CAAC,IAAP,CAAY,KAAZ,EAAmB,CAAnB,IAAqB,GAArB,IACR,MAAM,CAAC,MAAP,GAAgB,CAAhB,GACI,OAAO,KAAI,CAAC,cAAL,CAAoB,MAApB,CAAP,GAA+C,IADnD,GAEI,EAHI,CAAV;AAKD,OAPM,MAOA;AACL,eAAO,KAAG,KAAV;AACD;AACF,KAdH,EAeG,IAfH,CAeQ,IAfR,CADS,GAiBT,EAjBJ;AAkBD,GAnBa;;AAqBA,EAAA,KAAA,CAAA,mBAAA,GAAd,UAAkC,KAAlC,EAAoD;AAClD,WAAU,KAAK,CAAC,SAAN,GAAe,GAAf,GAAmB,KAAK,2BAAL,CAC3B,KAAK,CAAC,SADqB,CAAnB,GAET,GAFS,IAGR,KAAK,CAAC,MAAN,CAAa,MAAb,GAAsB,CAAtB,GACI,OAAO,KAAK,cAAL,CAAoB,KAAK,CAAC,MAA1B,CAAP,GAA2C,IAD/C,GAEI,EALI,CAAV;AAOD,GARa,CA9ChB,CAwDE;;;AACc,EAAA,KAAA,CAAA,iBAAA,GAAd,UAAgC,SAAhC,EAAgD,MAAhD,EAA+D;AAC7D,QAAM,eAAe,GAA+B,EAApD;;AACA,QAAM,MAAM,GAAG,UAAC,IAAD,EAAU;AACvB,UAAI,IAAJ,EAAU;AACR,QAAA,MAAM,CAAC,IAAP,CAAY,IAAZ,EAAkB,GAAlB,CAAsB,UAAC,GAAD,EAAI;AACxB,UAAA,eAAe,CAAC,GAAD,CAAf,GACE,OAAO,IAAI,CAAC,GAAD,CAAX,KAAqB,QAArB,GAAgC,IAAI,CAAC,GAAD,CAAJ,CAAU,KAA1C,GAAkD,IAAI,CAAC,GAAD,CADxD;AAED,SAHD;AAID;AACF,KAPD;;AASA,IAAA,MAAM,CAAC,SAAD,CAAN;;AACA,QAAI,MAAM,IAAI,OAAO,MAAP,KAAkB,QAAhC,EAA0C;AACxC,MAAA,MAAM,CAAC,KAAK,CAAC,kBAAN,CAAyB,MAAzB,CAAD,CAAN;AACD;;AACD,WAAO,eAAP;AACD,GAhBa;;AAkBA,EAAA,KAAA,CAAA,kBAAA,GAAd,UAAiC,MAAjC,EAA+C;AAC7C,QAAI,SAAS,GAAG,EAAhB;AACA,IAAA,MAAM,KAAA,IAAN,IAAA,MAAM,KAAA,KAAA,CAAN,GAAM,KAAA,CAAN,GAAA,MAAM,CAAE,OAAR,CAAgB,UAAC,KAAD,EAAqC;AACnD,UAAI,aAAA,CAAA,aAAA,CAAc,KAAd,CAAJ,EAA0B;AACxB,QAAA,SAAS,GAAA,QAAA,CAAA,QAAA,CAAA,QAAA,CAAA,EAAA,EACJ,KAAK,CAAC,SADF,CAAA,EAEJ,SAFI,CAAA,EAGH,KAAK,CAAC,MAAN,IAAgB,KAAK,CAAC,kBAAN,CAAyB,KAAK,CAAC,MAA/B,CAHb,CAAT;AAKD;AACF,KARD,CAAA;AASA,WAAO,SAAP;AACD,GAZa;;AAcA,EAAA,KAAA,CAAA,aAAA,GAAd,UAA4B,QAA5B,EAAyC;AACvC,QAAI,IAAI,GAAG,QAAX;AAEA,QAAM,KAAK,GAAG,OAAO,QAAP,KAAoB,QAApB,GAA+B,QAAQ,CAAC,KAAxC,GAAgD,QAA9D;;AAEA,QAAI,CAAA,QAAQ,KAAA,IAAR,IAAA,QAAQ,KAAA,KAAA,CAAR,GAAQ,KAAA,CAAR,GAAA,QAAQ,CAAE,IAAV,KAAkB,IAAtB,EAA4B;AAC1B,MAAA,IAAI,GAAG,QAAQ,CAAC,IAAhB;AACD,KAFD,MAEO;AACL;AACA,UAAM,cAAc,GAAG,KAAK,CAAC,OAAN,CAAc,KAAd,IAAuB,KAAK,CAAC,CAAD,CAA5B,GAAkC,KAAzD;;AACA,cAAQ,OAAO,cAAf;AACE,aAAK,QAAL;AACE,UAAA,IAAI,GAAG,QAAP;AACA;;AAEF,aAAK,SAAL;AACE,UAAA,IAAI,GAAG,SAAP;AACA;;AAEF,aAAK,QAAL;AACE,UAAA,IAAI,GAAG,cAAc,GAAG,CAAjB,KAAuB,CAAvB,GAA2B,KAA3B,GAAmC,OAA1C;AACA;AAXJ;AAaD,KAvBsC,CAyBvC;;;AACA,QAAI,OAAO,QAAP,KAAoB,QAAxB,EAAkC;AAChC,UAAI,QAAQ,CAAC,IAAT,KAAkB,IAAtB,EAA4B;AAC1B,QAAA,IAAI,GAAG,MAAI,IAAJ,GAAQ,GAAf;AACD,OAFD,MAEO,IAAI,KAAK,CAAC,OAAN,CAAc,QAAQ,CAAC,IAAvB,CAAJ,EAAkC;AACvC,QAAA,IAAI,GAAG,MAAI,IAAJ,IAAW,QAAQ,CAAC,IAAT,CAAc,CAAd,IAAmB,GAAnB,GAAyB,EAApC,IAAsC,GAA7C;AACD;;AAED,UAAI,QAAQ,CAAC,QAAb,EAAuB;AACrB,QAAA,IAAI,IAAI,GAAR;AACD;AACF;;AAED,WAAO,IAAP;AACD,GAvCa;;AAwChB,SAAA,KAAA;AAAC,CAjID,EAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar NestedField_1 = require(\"./NestedField\");\nvar Utils = /** @class */ (function () {\n    function Utils() {\n    }\n    Utils.resolveVariables = function (operations) {\n        var ret = {};\n        for (var _i = 0, operations_1 = operations; _i < operations_1.length; _i++) {\n            var _a = operations_1[_i], variables = _a.variables, fields = _a.fields;\n            ret = __assign(__assign(__assign({}, ret), variables), ((fields && Utils.getNestedVariables(fields)) || {}));\n        }\n        return ret;\n    };\n    // Convert object to name and argument map. eg: (id: $id)\n    Utils.queryDataNameAndArgumentMap = function (variables) {\n        return variables && Object.keys(variables).length\n            ? \"(\" + Object.entries(variables).reduce(function (dataString, _a, i) {\n                var key = _a[0], value = _a[1];\n                return \"\" + dataString + (i !== 0 ? \", \" : \"\") + (value && value.name ? value.name : key) + \": $\" + key;\n            }, \"\") + \")\"\n            : \"\";\n    };\n    Utils.queryFieldsMap = function (fields) {\n        var _this = this;\n        return fields\n            ? fields\n                .map(function (field) {\n                if (NestedField_1.isNestedField(field)) {\n                    return Utils.queryNestedFieldMap(field);\n                }\n                else if (typeof field === \"object\") {\n                    var values = Object.values(field)[0];\n                    return Object.keys(field)[0] + \" \" + (values.length > 0\n                        ? \"{ \" + _this.queryFieldsMap(values) + \" }\"\n                        : \"\");\n                }\n                else {\n                    return \"\" + field;\n                }\n            })\n                .join(\", \")\n            : \"\";\n    };\n    Utils.queryNestedFieldMap = function (field) {\n        return field.operation + \" \" + this.queryDataNameAndArgumentMap(field.variables) + \" \" + (field.fields.length > 0\n            ? \"{ \" + this.queryFieldsMap(field.fields) + \" }\"\n            : \"\");\n    };\n    // Variables map. eg: { \"id\": 1, \"name\": \"Jon Doe\" }\n    Utils.queryVariablesMap = function (variables, fields) {\n        var variablesMapped = {};\n        var update = function (vars) {\n            if (vars) {\n                Object.keys(vars).map(function (key) {\n                    variablesMapped[key] =\n                        typeof vars[key] === \"object\" ? vars[key].value : vars[key];\n                });\n            }\n        };\n        update(variables);\n        if (fields && typeof fields === \"object\") {\n            update(Utils.getNestedVariables(fields));\n        }\n        return variablesMapped;\n    };\n    Utils.getNestedVariables = function (fields) {\n        var variables = {};\n        fields === null || fields === void 0 ? void 0 : fields.forEach(function (field) {\n            if (NestedField_1.isNestedField(field)) {\n                variables = __assign(__assign(__assign({}, field.variables), variables), (field.fields && Utils.getNestedVariables(field.fields)));\n            }\n        });\n        return variables;\n    };\n    Utils.queryDataType = function (variable) {\n        var type = \"String\";\n        var value = typeof variable === \"object\" ? variable.value : variable;\n        if ((variable === null || variable === void 0 ? void 0 : variable.type) != null) {\n            type = variable.type;\n        }\n        else {\n            // TODO: Should handle the undefined value (either in array value or single value)\n            var candidateValue = Array.isArray(value) ? value[0] : value;\n            switch (typeof candidateValue) {\n                case \"object\":\n                    type = \"Object\";\n                    break;\n                case \"boolean\":\n                    type = \"Boolean\";\n                    break;\n                case \"number\":\n                    type = candidateValue % 1 === 0 ? \"Int\" : \"Float\";\n                    break;\n            }\n        }\n        // set object based variable properties\n        if (typeof variable === \"object\") {\n            if (variable.list === true) {\n                type = \"[\" + type + \"]\";\n            }\n            else if (Array.isArray(variable.list)) {\n                type = \"[\" + type + (variable.list[0] ? \"!\" : \"\") + \"]\";\n            }\n            if (variable.required) {\n                type += \"!\";\n            }\n        }\n        return type;\n    };\n    return Utils;\n}());\nexports.default = Utils;\n//# sourceMappingURL=Utils.js.map"]},"metadata":{},"sourceType":"script"}